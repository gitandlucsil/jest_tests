"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitBuilder = void 0;
require("reflect-metadata");
const mock_resolver_1 = require("./mock-resolver");
class UnitBuilder {
    constructor(reflector, mockFn, targetClass) {
        this.reflector = reflector;
        this.mockFn = mockFn;
        this.targetClass = targetClass;
        this.overloadsMap = new Map();
        this.depNamesToMocks = new Map();
        this.unitDeps = this.reflector.getMetadata('design:paramtypes', this.targetClass);
    }
    mock(dependency) {
        return {
            using: (mockImplementation) => {
                this.overloadsMap.set(dependency, this.mockFn(mockImplementation));
                return this;
            },
        };
    }
    mockDeep(dependency) {
        return {
            using: (mockImplementation) => {
                this.overloadsMap.set(dependency, this.mockFn(mockImplementation, { deep: true }));
                return this;
            },
        };
    }
    compile(deep = false) {
        this.mockUnMockedDependencies(deep);
        const values = Array.from(this.depNamesToMocks.values());
        return {
            unit: new this.targetClass(...values),
            unitRef: new mock_resolver_1.MockResolver(this.depNamesToMocks),
        };
    }
    mockUnMockedDependencies(deep = false) {
        this.unitDeps.forEach((dependency) => {
            const overriddenDep = this.overloadsMap.get(dependency);
            const mock = overriddenDep
                ? overriddenDep
                : this.mockFn(undefined, { deep });
            this.depNamesToMocks.set(dependency, mock);
        });
    }
}
exports.UnitBuilder = UnitBuilder;
